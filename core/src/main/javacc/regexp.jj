PARSER_BEGIN(RegExp)package net.ericaro.diezel.core.graph;import java.io.StringReader;import net.ericaro.diezel.core.flow.DiezelSax;import java.util.Deque;import java.util.LinkedList;import java.util.List;public class RegExp {  static Token t; //for local reuse do not use for long term calls over a non terminal  static boolean init= false;// for debug public static void print(Object o){System.out.println();}  public static <T> void parse(String code, DiezelSax<T> sax) throws ParseException{      if (!init)      {        new RegExp(new StringReader(code));        init = true;      }      else RegExp.ReInit(new StringReader(code));      RegExp.Flow(sax);    }}PARSER_END(RegExp)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])+ "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}< COMMENT > TOKEN :{< COMMENT_TEXT :(~["*"])*>| < COMMENT_END : "*/"  >  :DEFAULT}TOKEN :{  < STAR : "*" >| < PLUS : "+" >| < OPT : "?" >| < BANG : "&" >| < SEL : "|" >| < SEQ : "," >| < LEFT : "(" >| < RIGHT : ")" >| < EQUALS : "=" >| < END : ";" >| < ANNOTATION_START : "<" >| < ANNOTATION_END : ">" >| < COMMENT_START : "/**" >: COMMENT| <#LETTER : [ "a"-"z", "A"-"Z"] >| <#DIGIT : [ "0"-"9"] >| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT > | "_")* >}_T_void Comment(DiezelSax<T> sax) :{T v;Token t; }{  < COMMENT_START > (< COMMENT_TEXT >)* ("*" < COMMENT_TEXT > )* < COMMENT_END >}_T_T Transition(DiezelSax<T> sax) :{T v;Token t; String capture="";String types=""; }{  capture=Annotation(sax) t= < IDENTIFIER > (<LEFT >  types = Types(sax)  < RIGHT >)?    { return sax.terminal(capture, t.image, types.split(",")); }}_T_String Types(DiezelSax<T> sax) :{ String s;StringBuilder sb = new StringBuilder();}{  s= Type(sax)  {sb.append(s); }    ("," s=Type(sax) {sb.append(",").append(s); })*  {return sb.toString();}}_T_String Type(DiezelSax<T> sax) :{T v;Token to; String s,identifier;}{  to= < IDENTIFIER > {identifier=to.image;} ( "." to=< IDENTIFIER >{ identifier+="."+to.image;})*   ("..." {identifier+="...";})?   s = Annotation(sax) {return identifier+s; } }_T_String Annotation(DiezelSax<T> sax) :{T v;Token t; String s="";}{  (< ANNOTATION_START > ( s= Types(sax) )? <ANNOTATION_END > {return "<"+s+">"; } )?  {return "";  }}_T_void Flow(DiezelSax<T> sax) :{T v;Token t; }{  v=Exp(sax)   { sax.flow(v);}       }_T_T Exp( DiezelSax<T> sax) :{T v1,v2;}{  v1 = Sel(sax)    (    < SEQ > v2= Sel(sax) { v1=sax.seq(v1,v2); }      )*  { return v1; }  }_T_T Sel( DiezelSax<T> sax) :{T v1,v2;}{  v1=Bang(sax)  (        < SEL > v2=Bang(sax) { v1= sax.sel(v1,v2); }      )*  { return v1; }      }_T_T Bang( DiezelSax<T> sax) :{ T v;Deque<T> bangs = new LinkedList<T>();}{  v=Unary(sax) {bangs.push(v); }    (    < BANG > v=Unary(sax)    { bangs.push(v); }     )*  { return sax.bang(bangs); }    }_T_T Unary( DiezelSax<T> sax) :{T v;}{  ( < LEFT > v=Exp(sax) < RIGHT >  | v= Transition(sax)  )  (    < STAR >  { v= sax.star(v); }  | < PLUS > { v=sax.plus(v); }  | < OPT > { v= sax.opt(v); }  )?  {return v; }}
