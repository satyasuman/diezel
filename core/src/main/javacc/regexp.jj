PARSER_BEGIN(RegExp)package net.ericaro.diezel.core.parser;import java.io.StringReader;import net.ericaro.diezel.core.parser.DiezelSax;import java.util.Deque;import java.util.LinkedList;public class RegExp {  static Token t; //for local reuse do not use for long term calls over a non terminal  static boolean init= false; // for debug public static void print(Object o){System.out.println();}  public static void parse(String code, DiezelSax sax) throws ParseException{      if (!init)      {        new RegExp(new StringReader(code));        init = true;      }      else RegExp.ReInit(new StringReader(code));      RegExp.Flow(sax);    }}PARSER_END(RegExp)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])+ "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN :{  < STAR : "*" >| < PLUS : "+" >| < OPT : "?" >| < BANG : "&" >| < SEL : "|" >| < SEQ : "," >| < LEFT : "(" >| < RIGHT : ")" >| <#LETTER : [ "_", "a"-"z", "A"-"Z"] >| <#DIGIT : [ "0"-"9"] >| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT > )* >}/** Top level grammar entry, a flow is a single expression.*/void Flow(DiezelSax sax) :{Object v;Token t; }{  v=Exp(sax)   { sax.flow(v);}       }Object Exp( DiezelSax sax) :{Object v1,v2;}{  v1 = Sel(sax)    (    < SEQ > v2= Sel(sax) { v1=sax.seq(v1,v2); }      )*  { return v1; }  }Object Sel( DiezelSax sax) :{Object v1,v2;}{  v1=Bang(sax)  (        < SEL > v2=Bang(sax) { v1= sax.sel(v1,v2); }      )*  { return v1; }      }Object Bang( DiezelSax sax) :{ Object v;Deque bangs = new LinkedList();}{  v=Unary(sax) {bangs.push(v); }    (    < BANG > v=Unary(sax)    { bangs.push(v); }     )*  { return sax.bang(bangs); }    }Object Unary( DiezelSax sax) :{Object v;}{  ( < LEFT > v=Exp(sax) < RIGHT >  | v= Transition(sax)  )  (    < STAR >  { v= sax.star(v); }  | < PLUS > { v=sax.plus(v); }  | < OPT > { v= sax.opt(v); }  )?  {return v; }}Object Transition(DiezelSax sax) :{}{  t= < IDENTIFIER >    { return sax.terminal(t.image); }}
