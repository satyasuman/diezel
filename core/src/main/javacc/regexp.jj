PARSER_BEGIN(RegExp)package net.ericaro.diezel.core.parser;import java.io.StringReader;import net.ericaro.diezel.core.parser.DiezelSax;import java.util.Deque;import java.util.LinkedList;public class RegExp {  static Token t; //for local reuse do not use for long term calls over a non terminal  static boolean init= false;// for debug public static void print(Object o){System.out.println();}  public static void parse(String code, DiezelSax sax) throws ParseException{      if (!init)      {        new RegExp(new StringReader(code));        init = true;      }      else RegExp.ReInit(new StringReader(code));      RegExp.Flow(sax);    }}PARSER_END(RegExp)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])+ "*"    (      "*"    | ~[ "*", "/" ] (~[ "*" ])* "*"    )*    "/" >}< COMMENT > TOKEN :{< COMMENT_TEXT :(~["*"])*>| < COMMENT_END : "*/"  >  :DEFAULT}TOKEN :{  < STAR : "*" >| < PLUS : "+" >| < OPT : "?" >| < BANG : "&" >| < SEL : "|" >| < SEQ : "," >| < LEFT : "(" >| < RIGHT : ")" >| < EQUALS : "=" >| < END : ";" >| < RETURN : "return" >| < CALL : "call" >| < ANNOTATION_START : "<" >| < ANNOTATION_END : ">" >| < COMMENT_START : "/**" >: COMMENT| <#LETTER : [ "a"-"z", "A"-"Z"] >| <#DIGIT : [ "0"-"9"] >| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT > | "_")* >}void Comment(DiezelSax sax) :{Object v;Token t; }{  < COMMENT_START > (< COMMENT_TEXT >)* ("*" < COMMENT_TEXT > )* < COMMENT_END >}/*Object Transition(DiezelSax sax) :{Object v;Token t; String capture="";String types=""; TransitionType returns = TransitionType.SIMPLE;}{  (< RETURN > {returns = TransitionType.RETURN; } | < CALL > {returns = TransitionType.CALL;  })?  capture=Annotation(sax) t= < IDENTIFIER > (<LEFT >  types = Types(sax)  < RIGHT >)?    { return sax.terminal(returns, capture, t.image, types.split(",")); }}String Types(DiezelSax sax) :{ String s;StringBuilder sb = new StringBuilder();}{  s= Type(sax)  {sb.append(s); }    ("," s=Type(sax) {sb.append(",").append(s); })*  {return sb.toString();}}String Type(DiezelSax sax) :{Object v;Token to; String s,identifier;}{  to= < IDENTIFIER > {identifier=to.image;} ( "." to=< IDENTIFIER >{ identifier+="."+to.image;})*   ("..." {identifier+="...";})?   s = Annotation(sax) {return identifier+s; } }String Annotation(DiezelSax sax) :{Object v;Token t; String s="";}{  (< ANNOTATION_START > ( s= Types(sax) )? <ANNOTATION_END > {return "<"+s+">"; } )?  {return "";  }}*/void Flow(DiezelSax sax) :{Object v;Token t; }{  v=Exp(sax)   { sax.flow(v);}       }Object Exp( DiezelSax sax) :{Object v1,v2;}{  v1 = Sel(sax)    (    < SEQ > v2= Sel(sax) { v1=sax.seq(v1,v2); }      )*  { return v1; }  }Object Sel( DiezelSax sax) :{Object v1,v2;}{  v1=Bang(sax)  (        < SEL > v2=Bang(sax) { v1= sax.sel(v1,v2); }      )*  { return v1; }      }Object Bang( DiezelSax sax) :{ Object v;Deque bangs = new LinkedList();}{  v=Unary(sax) {bangs.push(v); }    (    < BANG > v=Unary(sax)    { bangs.push(v); }     )*  { return sax.bang(bangs); }    }Object Unary( DiezelSax sax) :{Object v;}{  ( < LEFT > v=Exp(sax) < RIGHT >  | v= Transition(sax)  )  (    < STAR >  { v= sax.star(v); }  | < PLUS > { v=sax.plus(v); }  | < OPT > { v= sax.opt(v); }  )?  {return v; }}Object Transition(DiezelSax sax) :{}{  t= < IDENTIFIER >    { return sax.terminal(t.image); }}
